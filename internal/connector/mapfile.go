package connector

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strings"
	"sync"

	"github.com/pscheit/haproxy-nomad-connector/internal/haproxy"
)

// DomainMapManager manages HAProxy domain-backend map files
type DomainMapManager struct {
	filePath string
	mutex    sync.RWMutex
	mappings map[string]*haproxy.DomainMapping // domain -> mapping
}

// NewDomainMapManager creates a new domain map manager
func NewDomainMapManager(filePath string) *DomainMapManager {
	return &DomainMapManager{
		filePath: filePath,
		mappings: make(map[string]*haproxy.DomainMapping),
	}
}

// LoadFromFile loads existing domain mappings from the map file
func (dmm *DomainMapManager) LoadFromFile() error {
	dmm.mutex.Lock()
	defer dmm.mutex.Unlock()

	file, err := os.Open(dmm.filePath)
	if err != nil {
		if os.IsNotExist(err) {
			// File doesn't exist yet, that's fine
			return nil
		}
		return fmt.Errorf("failed to open map file %s: %w", dmm.filePath, err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip comments and empty lines
		if line == "" || strings.HasPrefix(line, "#") {
			continue
		}

		// Parse line: "domain backend_name"
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			domain := parts[0]
			backendName := parts[1]

			dmm.mappings[domain] = &haproxy.DomainMapping{
				Domain:      domain,
				BackendName: backendName,
				Type:        haproxy.DomainTypeExact, // assume exact for existing entries
			}
		}
	}

	return scanner.Err()
}

// AddMapping adds or updates a domain mapping
func (dmm *DomainMapManager) AddMapping(mapping *haproxy.DomainMapping) {
	dmm.mutex.Lock()
	defer dmm.mutex.Unlock()

	dmm.mappings[mapping.Domain] = mapping
}

// RemoveMapping removes a domain mapping
func (dmm *DomainMapManager) RemoveMapping(domain string) {
	dmm.mutex.Lock()
	defer dmm.mutex.Unlock()

	delete(dmm.mappings, domain)
}

// GetMapping retrieves a domain mapping
func (dmm *DomainMapManager) GetMapping(domain string) (*haproxy.DomainMapping, bool) {
	dmm.mutex.RLock()
	defer dmm.mutex.RUnlock()

	mapping, exists := dmm.mappings[domain]
	return mapping, exists
}

// GetAllMappings returns all domain mappings
func (dmm *DomainMapManager) GetAllMappings() map[string]*haproxy.DomainMapping {
	dmm.mutex.RLock()
	defer dmm.mutex.RUnlock()

	result := make(map[string]*haproxy.DomainMapping)
	for k, v := range dmm.mappings {
		result[k] = v
	}
	return result
}

// WriteToFile writes the current domain mappings to the map file
func (dmm *DomainMapManager) WriteToFile() error {
	dmm.mutex.RLock()
	defer dmm.mutex.RUnlock()

	// Create temporary file first
	tempFile := dmm.filePath + ".tmp"
	file, err := os.Create(tempFile)
	if err != nil {
		return fmt.Errorf("failed to create temp file %s: %w", tempFile, err)
	}
	defer file.Close()

	// Write header comment
	fmt.Fprintln(file, "# Domain to backend mapping")
	fmt.Fprintln(file, "# Generated by haproxy-nomad-connector")

	// Sort domains for consistent output
	domains := make([]string, 0, len(dmm.mappings))
	for domain := range dmm.mappings {
		domains = append(domains, domain)
	}
	sort.Strings(domains)

	// Write mappings
	for _, domain := range domains {
		mapping := dmm.mappings[domain]
		// Format: domain backend_name
		// For now, we only output exact matches in the simple format
		// TODO: Handle prefix/regex types if needed
		fmt.Fprintf(file, "%-30s %s\n", mapping.Domain, mapping.BackendName)
	}

	// Sync and close
	if err := file.Sync(); err != nil {
		return fmt.Errorf("failed to sync temp file: %w", err)
	}

	// Atomic move
	if err := os.Rename(tempFile, dmm.filePath); err != nil {
		return fmt.Errorf("failed to move temp file to %s: %w", dmm.filePath, err)
	}

	return nil
}

// Size returns the number of domain mappings
func (dmm *DomainMapManager) Size() int {
	dmm.mutex.RLock()
	defer dmm.mutex.RUnlock()

	return len(dmm.mappings)
}
