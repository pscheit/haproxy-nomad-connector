package connector

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/pscheit/haproxy-nomad-connector/internal/haproxy"
)

func TestDomainMapManager_LoadFromFile(t *testing.T) {
	// Create temporary file
	tmpDir := t.TempDir()
	mapFile := filepath.Join(tmpDir, "domain-backend.map")

	// Write test data
	testContent := `# Domain to backend mapping
api.example.com                api_service
web.example.com                web_service
# comment line
database.internal              db_backend

# another comment
cache.example.com              cache_service
`
	err := os.WriteFile(mapFile, []byte(testContent), 0644)
	if err != nil {
		t.Fatalf("Failed to write test file: %v", err)
	}

	// Test loading
	dmm := NewDomainMapManager(mapFile)
	err = dmm.LoadFromFile()
	if err != nil {
		t.Fatalf("LoadFromFile() failed: %v", err)
	}

	// Verify mappings
	expectedMappings := map[string]string{
		"api.example.com":    "api_service",
		"web.example.com":    "web_service", 
		"database.internal":  "db_backend",
		"cache.example.com":  "cache_service",
	}

	if dmm.Size() != len(expectedMappings) {
		t.Errorf("Expected %d mappings, got %d", len(expectedMappings), dmm.Size())
	}

	for domain, expectedBackend := range expectedMappings {
		mapping, exists := dmm.GetMapping(domain)
		if !exists {
			t.Errorf("Expected mapping for domain %s not found", domain)
			continue
		}

		if mapping.BackendName != expectedBackend {
			t.Errorf("Domain %s: expected backend %s, got %s", domain, expectedBackend, mapping.BackendName)
		}

		if mapping.Type != haproxy.DomainTypeExact {
			t.Errorf("Domain %s: expected type %s, got %s", domain, haproxy.DomainTypeExact, mapping.Type)
		}
	}
}

func TestDomainMapManager_LoadFromNonExistentFile(t *testing.T) {
	tmpDir := t.TempDir()
	mapFile := filepath.Join(tmpDir, "nonexistent.map")

	dmm := NewDomainMapManager(mapFile)
	err := dmm.LoadFromFile()
	
	// Should not error on non-existent file
	if err != nil {
		t.Errorf("LoadFromFile() should not error on non-existent file: %v", err)
	}

	if dmm.Size() != 0 {
		t.Errorf("Expected 0 mappings for non-existent file, got %d", dmm.Size())
	}
}

func TestDomainMapManager_AddRemoveMapping(t *testing.T) {
	dmm := NewDomainMapManager("/tmp/test.map")

	// Add mapping
	mapping := &haproxy.DomainMapping{
		Domain:      "test.example.com",
		BackendName: "test_backend",
		Type:        haproxy.DomainTypeExact,
	}
	
	dmm.AddMapping(mapping)

	// Verify added
	retrieved, exists := dmm.GetMapping("test.example.com")
	if !exists {
		t.Error("Mapping should exist after adding")
	}

	if retrieved.BackendName != "test_backend" {
		t.Errorf("Expected backend test_backend, got %s", retrieved.BackendName)
	}

	if dmm.Size() != 1 {
		t.Errorf("Expected size 1, got %d", dmm.Size())
	}

	// Remove mapping
	dmm.RemoveMapping("test.example.com")

	// Verify removed
	_, exists = dmm.GetMapping("test.example.com")
	if exists {
		t.Error("Mapping should not exist after removing")
	}

	if dmm.Size() != 0 {
		t.Errorf("Expected size 0 after removal, got %d", dmm.Size())
	}
}

func TestDomainMapManager_WriteToFile(t *testing.T) {
	tmpDir := t.TempDir()
	mapFile := filepath.Join(tmpDir, "test-output.map")

	dmm := NewDomainMapManager(mapFile)

	// Add some mappings
	mappings := []*haproxy.DomainMapping{
		{
			Domain:      "api.example.com",
			BackendName: "api_service",
			Type:        haproxy.DomainTypeExact,
		},
		{
			Domain:      "web.example.com", 
			BackendName: "web_service",
			Type:        haproxy.DomainTypeExact,
		},
		{
			Domain:      "cache.example.com",
			BackendName: "cache_backend",
			Type:        haproxy.DomainTypePrefix,
		},
	}

	for _, mapping := range mappings {
		dmm.AddMapping(mapping)
	}

	// Write to file
	err := dmm.WriteToFile()
	if err != nil {
		t.Fatalf("WriteToFile() failed: %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(mapFile); os.IsNotExist(err) {
		t.Error("Map file should exist after writing")
	}

	// Read and verify content
	content, err := os.ReadFile(mapFile)
	if err != nil {
		t.Fatalf("Failed to read written file: %v", err)
	}

	contentStr := string(content)
	
	// Check for header comments
	if !containsString(contentStr, "# Domain to backend mapping") {
		t.Error("Written file should contain header comment")
	}

	if !containsString(contentStr, "# Generated by haproxy-nomad-connector") {
		t.Error("Written file should contain generator comment")
	}

	// Debug: Print actual content
	t.Logf("Actual file content:\n%s", contentStr)

	// Check for all mappings (with proper formatting)
	for _, mapping := range mappings {
		// Check that domain and backend appear on the same line
		if !containsString(contentStr, mapping.Domain) {
			t.Errorf("Written file should contain domain: %s", mapping.Domain)
		}
		if !containsString(contentStr, mapping.BackendName) {
			t.Errorf("Written file should contain backend: %s", mapping.BackendName)
		}
	}
}

func TestDomainMapManager_GetAllMappings(t *testing.T) {
	dmm := NewDomainMapManager("/tmp/test.map")

	// Add mappings
	mapping1 := &haproxy.DomainMapping{
		Domain:      "api.example.com",
		BackendName: "api_service",
		Type:        haproxy.DomainTypeExact,
	}
	mapping2 := &haproxy.DomainMapping{
		Domain:      "web.example.com",
		BackendName: "web_service", 
		Type:        haproxy.DomainTypePrefix,
	}

	dmm.AddMapping(mapping1)
	dmm.AddMapping(mapping2)

	// Get all mappings
	allMappings := dmm.GetAllMappings()

	if len(allMappings) != 2 {
		t.Errorf("Expected 2 mappings, got %d", len(allMappings))
	}

	// Verify both mappings exist
	if _, exists := allMappings["api.example.com"]; !exists {
		t.Error("api.example.com mapping should exist")
	}

	if _, exists := allMappings["web.example.com"]; !exists {
		t.Error("web.example.com mapping should exist")
	}

	// Verify returned map is a copy (not the original)
	delete(allMappings, "api.example.com")
	
	// Original should still have the mapping
	if _, exists := dmm.GetMapping("api.example.com"); !exists {
		t.Error("Original mapping should still exist after modifying returned copy")
	}
}

func TestDomainMapManager_RoundTrip(t *testing.T) {
	tmpDir := t.TempDir()
	mapFile := filepath.Join(tmpDir, "roundtrip.map")

	// Create manager and add mappings
	dmm1 := NewDomainMapManager(mapFile)
	originalMappings := []*haproxy.DomainMapping{
		{Domain: "api.example.com", BackendName: "api_service", Type: haproxy.DomainTypeExact},
		{Domain: "web.example.com", BackendName: "web_service", Type: haproxy.DomainTypeExact},
		{Domain: "db.internal", BackendName: "database_backend", Type: haproxy.DomainTypeExact},
	}

	for _, mapping := range originalMappings {
		dmm1.AddMapping(mapping)
	}

	// Write to file
	err := dmm1.WriteToFile()
	if err != nil {
		t.Fatalf("WriteToFile() failed: %v", err)
	}

	// Create new manager and load from file
	dmm2 := NewDomainMapManager(mapFile)
	err = dmm2.LoadFromFile()
	if err != nil {
		t.Fatalf("LoadFromFile() failed: %v", err)
	}

	// Verify all mappings are preserved
	if dmm2.Size() != len(originalMappings) {
		t.Errorf("Expected %d mappings after round trip, got %d", len(originalMappings), dmm2.Size())
	}

	for _, original := range originalMappings {
		loaded, exists := dmm2.GetMapping(original.Domain)
		if !exists {
			t.Errorf("Mapping for domain %s should exist after round trip", original.Domain)
			continue
		}

		if loaded.BackendName != original.BackendName {
			t.Errorf("Domain %s: expected backend %s, got %s after round trip", 
				original.Domain, original.BackendName, loaded.BackendName)
		}
	}
}

// Helper function to check if string contains substring
func containsString(text, substr string) bool {
	return strings.Contains(text, substr)
}